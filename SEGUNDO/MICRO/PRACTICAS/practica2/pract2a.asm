;**************************************************************************
; PRACTICA 2, EJERCICIO A -> TOMAS HIGUERA VISO Y GUILLERMO HOYO BRAVO, PAREJA 1
;**************************************************************************
; DEFINICION DEL SEGMENTO DE DATOS
	DATOS SEGMENT
		cadena DB ?
	DATOS ENDS
;**************************************************************************
; DEFINICION DEL SEGMENTO DE PILA
	PILA SEGMENT STACK "STACK"
		DB 40H DUP (0) ;ejemplo de inicialización, 64 bytes inicializados a 0
	PILA ENDS
;**************************************************************************
; DEFINICION DEL SEGMENTO EXTRA
	EXTRA SEGMENT
		RESULT DW 0,0 ;ejemplo de inicialización. 2 PALABRAS (4 BYTES)
	EXTRA ENDS
;**************************************************************************
; DEFINICION DEL SEGMENTO DE CODIGO
	CODE SEGMENT
		ASSUME CS: CODE, DS: DATOS, ES: EXTRA, SS: PILA
; COMIENZO DEL PROCEDIMIENTO PRINCIPAL
INICIO PROC
; INICIALIZA LOS REGISTROS DE SEGMENTO CON SU VALOR
	MOV AX, DATOS
	MOV DS, AX
	MOV AX, PILA
	MOV SS, AX
	MOV AX, EXTRA
	MOV ES, AX
	MOV SP, 64 ; CARGA EL PUNTERO DE PILA CON EL VALOR MAS ALTO
	MOV SI, 0
	MOV DI, 0
; FIN DE LAS INICIALIZACIONES

; COMIENZO DEL PROGRAMA
	; GUARDAMOS EN BX EL NUMERO QUE VAMOS A PASAR A ASCII
	MOV BX, 65535
	
	saveASCII:
		; GUARDAMOS EN DX 0000h PARA PODER ESCRIBIR CORRECTAMENTE EL DIVIDENDO DE 32 bits
		MOV DX, 0000h
		; GUARDAMOS EN AX EL NUMERO QUE VAMOS A DIVIDIR
		MOV AX, BX
		; GUARDAMOS EN CX EL DIVISOR, QUE EN ESTE CASO SERA 10, PARA PODER IR OBTENIENDO TODAS LAS CIFRAS DEL NUMERO
		MOV CX, 000Ah
		; DIVIDIMOS NUESTRO NUMERO ENTRE 10
		DIV CX
		; EL COCIENTE DE LA DIVISION LO GUARDAMOS EN BX PARA SEGUIR DIVIDIENDOLO EN BUCLE
		MOV BX, AX
		; EL RESTO LO GUARDAMOS EN AX(SERAN LAS CIFRAS DE NUESTRO NUMERO DESDE EL FINAL, UNA EN CADA BUCLE)
		MOV AX, DX
		; SUMAMOS 30h A LA CIFRA PARA TENER PASAR EL NUMERO AL CODIGO HEXADECIMAL QUE LE CORRESPONDE EN ASCII
		ADD AX, 30h
		; PUSHEAMOS EL NUMERO TRANSFORMADO EN LA PILA
		PUSH AX
		; AUEMENTAMOS SI PARA FACILITAR EL VACIADO DE LA PILA
		INC SI
		; COMPARAMOS SI EL COCIENTE ES IGUAL A 0h
		CMP BX, 0h
		; SI EL COCIENTE NO ES 0 SE SIGUE DIVIDENDO
		JNE saveASCII
		
	stackToCadena:
		; SACAMOS DE PILA Y GUARDAMOS EN LA CADENA
		POP BX
		; GUARDAMOS EN DX EL OFFSET DE LA CADENA PARA PODER ESCRIBIR EN EL FINAL DE LA MISMA
		MOV DX, OFFSET cadena
		; GUARDAMOS AL FINAL DE LA CADENA EL NUMERO EN ASCII 
		MOV cadena[DI], BL
		; DECREMENTAMOS SI PARA SABER CUANTOS CARACTERES EN ASCII QUEDAN EN LA PILA
		DEC SI
		; INCREMENTAMOS DI PARA ESCRIBIR EN LA SIGUIENTE POSICION DE LA CADENA
		INC DI
		; COMPARAMOS SI EL INDICE DE LA PILA ES IGUAL A 0
		CMP SI, 0
		; SI EL INDICE ES IGUAL QUE 0 SIGNIFICARA QUE HEMOS VACIADO LA PILA, POR LO QUE SALIMOS DEL BUCLE
		JNE stackToCadena
		
	; GUARDAMOS EN EL ULTIMO CARACTER DE LA CADENA EL CARACTER "$"	
	MOV cadena[DI], "$"
	; GUARDAMOS EL OFFSET DE LA CADENA EN DX
	MOV DX,OFFSET cadena
	; GUARDAMOS EN AH LA FUNCION PARA IMPRIMIR UNA CADENA DE CARACTERES
	MOV AH, 9
	; IMPRIMIMOS LA CADENA
	INT 21H
	
; FIN DEL PROGRAMA
	MOV AX, 4C00H
	INT 21H
	INICIO ENDP
; FIN DEL SEGMENTO DE CODIGO
CODE ENDS
; FIN DEL PROGRAMA INDICANDO DONDE COMIENZA LA EJECUCION
END INICIO 